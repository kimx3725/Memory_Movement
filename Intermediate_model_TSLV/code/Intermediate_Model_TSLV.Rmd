---
title: "1.amt_conv"
author: "Dennis Kim"
date: "2022-10-06"
output: html_document
---

# Objective 

To explore the structure of the bear data set. To do this, I will: 

1. Generate used and available locations of the bear through amt framework. 
2. Extract habitat covariate from habitat layer. 
3. Create sf polygons that define the buffer of each grid 
4. Calculate the points that fall within each buffer and save it as each raster layer 
5. Calculate the TSLV similar to Uli's approach 
6. Include TSLV values per each location and save them in the column of the data 
7. Fit SSF model with a TSLV predictor 

## Document Preamble 
```{r preamble, include = FALSE}
# load libraries
library(knitr)
library(dplyr)
library(readr)
library(data.table)
library(DT)
library(here)
library(stringr)
library(tidyr)
library(purrr)
library(amt)
library(ggplot2)
library(raster)
library(sf)
library(recurse)
library(scales)
library(sp)
library(geosphere)
library(generics)
library(sfheaders)
library(lubridate)
library(pastecs)
library(stats)
library(mapview)
library(tmap)
library(spatialEco)
library(paletteer)
library(wesanderson)
library(doBy)
library(stars)
library(viridis)
options(width = 150)

# set knitr options 
opts_chunk$set(fig.width = 6, fig.height = 5, comment = NA)
```

# Data preparation

## Prepare Tracking data 

Read in the gps data 
```{r read gps data}
# Location data of the bear 
bear <- read.csv(here::here("data", "GF1143_raw.csv"))

# change the time format of the data 
bear$datetime <- as.POSIXct(bear$datetime, format =  "%Y-%m-%d %H:%M")

# summary of the data
summary(bear)
```

Plot the data 
```{r bear location vis}
ggplot(bear, aes(x = x, y = y))+ 
  geom_point()
```

## Prepare environmental data 

Add environmental covariate (berry)
```{r habitat layer}
# call the berries layer
berry <- raster(here("data/berries/berries.tif"))

# plot the layer
plot(berry)

# crs of the layer 
crs(berry)
```


# AMT conversion with habitat predictor 

## amt conversion 

Add a track class to the data and summarize the data 
```{r amt conversion}
# make tracks 
trk.bear <- amt::make_track(bear, .x=x, .y=y, .t=datetime, crs=CRS("+init=epsg:26908"))

summary(trk.bear)
```

Summarize the sampling rates of the bear
```{r sampling rates}
# 4 hour sampling seems reasonable - no need to resample - since it is already resampled 
summarize_sampling_rate(trk.bear) 
```

change the track point to step 
1. Resample track and filter bursts 
2. Convert track to steps 
3. Create random steps 
4. Extract covariate values 
```{r retrk bear}
# follow the above approach 
ssfdat.bear <- 
  trk.bear %>% track_resample(rate = hours(4), tolerance = minutes(30)) %>% 
  steps_by_burst() %>% 
  random_steps(n_control = 3) %>% 
  extract_covariates(berry) %>% 
  filter(!is.na(ta_))

# summary of the ssf data
summary(ssfdat.bear)
```

Check the reasonable buffer distance for each step length - you can adjust this based on the summary of your step lengths 
```{r sl distribution}
ssfdat.bear %>% filter(case_ == "TRUE") %>% dplyr::select(sl_) %>% summary()
```

# Spatial temporal cognitive map

select randomized and used locations of the tracks from the ssfdat.bear for making a map
```{r st points}
# select random locations that matched with observed step lengths 
obs <- ssfdat.bear %>% filter(case_ == TRUE)
ran <- ssfdat.bear %>% filter(case_ == FALSE)

# select observed locations
obs.loc <- obs %>% dplyr::select(x1_, y1_)
colnames(obs.loc) <- c("x", "y")
obs.loc.sf <- st_as_sf(obs.loc, coords = c("x", "y"), crs = "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs")
obs.loc %>% head()

## mapview
#mapview(obs.loc.sf, cex = 3, alpha = 0.5, popup = NULL)

# select random locations
ran.loc <- ran %>% dplyr::select(x2_, y2_)
colnames(ran.loc) <- c("x", "y")
ran.loc.sf <- st_as_sf(ran.loc, coords = c("x", "y"), crs = "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs")
ran.loc %>% head()

## mapview
#mapview(ran.loc.sf, cex = 3, alpha = 0.5, popup = NULL)
```

we will first create a grid which the extent equals to the bounding box of the selected points
```{r memory map}
# create 2000m x 2000m grid cell in the map (24 x 20)
memory.map = st_make_grid(obs.loc.sf, c(2000, 2000), what = "polygons", square = TRUE)
memory.map

# convert the map to sf object
memory.map.sf = st_sf(memory.map)

# plot the map
memory.map.sf %>% plot()
```

## Time Since Last Vitist (TSLV)

Follow Uli's approach: Their definition of TSLV is short and sweet (see equation 4 in that paper) - basically, it's 0 if the point in question is within some distance Î´ (this value could be similar to the value you used for your buffer) of the previous point, and otherwise it's (previous TSLV + 1). So they define it iteratively, starting at the first point and iteratively updating TSLV with each time step.


General approaches: 
1. create a spatial temporal map with the number of cells (for our cases, we use the 2000m x 2000m buffer).
2. set the burn-in period (365 days - a year) - t index would correlate with the number of observation id 
3. calculate the tslv based on the year observations - at the end of the calculation, all the NAs would replace by 354 
4. continue the same approaches 
5. merge the tslv values to the observed locations 

### Observed Locations 

The entire time periods 
```{r entire}
# create all observed pts in list 
all.obs.list <- list() # save each visited layer 
all.obs.ras.list <- list() # save each visited raster layer

# for the entire (t = 534) 
for(i in 1:534){
# calculate the animal's visitation to a each grid cell (1 indicates animal visited that particular grid, otherwise 0)  
all.obs.list[[i]] <- memory.map.sf %>% mutate(visit = lengths(st_intersects(memory.map.sf, obs.loc.sf[i,1])))

# convert to raster
all.obs.ras.list[[i]] <- all.obs.list[[i]] %>% raster(ncol= 20, nrow = 24)

# insert the visited value per each raster map
values(all.obs.ras.list[[i]]) <- all.obs.list[[i]]$visit
}

all.obs.ras.list[[1]] %>% plot()
```

### calculate the time since last visit

Write function to calculate run length to specified value. If the specified run value (y) is the first value it returns a 0 and if it is missing then a NA is returned.
```{r tslv}
# tslv function
time.since.last.visit <- function(x, y=1, dir=c("LR", "RL")) {
    if(dir[1] == "RL") x <- rev(x)
    # compute the lengths and values of runs of equal values in a vector -- or the reverse operation
      x.idx <- rle(x)$values 
      v.idx <- rle(x)$lengths 
    # if the x is equal to y (1) visited   
    if(x[1] == y) {
      # then equal to 0
      v <- 0
    } else {
      # calculate the time since the last visit 
      v <- v.idx[which(x.idx == y)-1][1]
    }   
  return( v )
}

## stack all the raster layers: each layer will have a value of one observation at time t 
allr = raster::brick(all.obs.ras.list)
## calculate tslv 
(all.tslv <- calc(allr, fun=time.since.last.visit))

## plot the burn-in phase tslv values 
all.tslv %>% plot()

#Now, apply it to a raster stack example
obs.memory.map.sf <- memory.map.sf %>% mutate(tslv = values(all.tslv)) 

# only 135 individuals that have tslv values 
obs.memory.map.sf %>% data.frame() %>% filter(!is.na(tslv))
```



```{r obs: count grid}
# count number odfpoints in each grid
obs.memory.map.sf$visit = lengths(st_intersects(obs.memory.map.sf, obs.loc.sf))
obs.memory.map.sf$grid_id <- 1:nrow(obs.memory.map.sf)
# you can clear see that there are some missing values althought animals definitely have visited the locations - need to deal with the missing locations 

obs.memory.map.sf %>% as.data.frame() 
#obs.memory.map.sf %>% as.data.frame() %>% mutate(tslv1 = ifelse(is.na(tslv), 365, tslv))
```

Plot the cognitiv msp over the entire burn in time periods (dark color indicates more tslv values)
```{r, obs:grid map}
tmap_mode("view")

all_map_obs = tm_shape(obs.memory.map.sf) +
  tm_fill(
    col = "tslv",
    palette = "Reds",
    style = "cont",
    title = "Time since last visit",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.5,
    popup.vars = c(
      "Time Since last visit: " = "tslv"
    ),
    popup.format = list(
      tslv = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

all_map_obs
```

convert geometry back to lat and long
```{r obs:geom to latlong}
obs.memory.map.sf %>% as.data.frame() %>% filter(!is.na(tslv))


# include the number of visits to each cell in the map 
obs.tslv <- point.in.poly(obs.loc.sf, obs.memory.map.sf) %>% as.data.frame() 
obs.tslv
```

## Random Locations 

*[Do the exact same framework as above]*
```{r entire}
# create all observed pts in list 
ran.obs.list <- list() # save each visited layer 
ran.obs.ras.list <- list() # save each visited raster layer

# for the entire  
for(i in 1:1968){
# calculate the animal's visitation to a each grid cell (1 indicates animal visited that particular grid, otherwise 0)  
ran.obs.list[[i]] <- memory.map.sf %>% mutate(visit = lengths(st_intersects(memory.map.sf, ran.loc.sf[i,1])))

# convert to raster
ran.obs.ras.list[[i]] <- ran.obs.list[[i]] %>% raster(ncol= 20, nrow = 24)

# insert the visited value per each raster map
values(ran.obs.ras.list[[i]]) <- ran.obs.list[[i]]$visit
}

ran.obs.ras.list[[5]] %>% plot()
```

### calculate the time since last visit

Write function to calculate run length to specified value. If the specified run value (y) is the first value it returns a 0 and if it is missing then a NA is returned.
```{r tslv}
## stack ran the raster layers: each layer will have a value of one observation at time t 
ranr = raster::brick(ran.obs.ras.list)
## calculate tslv (apply the same function)
(ran.tslv <- calc(ranr, fun=time.since.last.visit))

## plot the burn-in phase tslv values 
ran.tslv %>% plot()

#Now, apply it to a raster stack example
r.memory.map.sf <- memory.map.sf %>% mutate(tslv = values(ran.tslv)) 

# only 135 individuals that have tslv values 
r.memory.map.sf %>% data.frame() %>% filter(!is.na(tslv))
```

```{r ran: count grid}
# count number of points in each grid
r.memory.map.sf$visit = lengths(st_intersects(r.memory.map.sf, ran.loc.sf))
r.memory.map.sf$grid_id <- 1:nrow(r.memory.map.sf)
# you can clear see that there are some missing values althought animals definitely have visited the locations - need to deal with the missing locations 

memory.map.sf %>% as.data.frame() %>% summary
#memory.map.sf %>% as.data.frame() %>% mutate(tslv1 = ifelse(is.na(tslv), 365, tslv))
```

Plot the cognitiv msp over the entire burn in time periods (dark color indicates more tslv values)
```{r, obs:grid map}
tmap_mode("view")

r_map_obs = tm_shape(r.memory.map.sf) +
  tm_fill(
    col = "tslv",
    palette = "Reds",
    style = "cont",
    title = "Time since last visit",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.5,
    popup.vars = c(
      "Time Since last visit: " = "tslv"
    ),
    popup.format = list(
      tslv = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

r_map_obs
```

convert geometry back to lat and long
```{r obs:geom to latlong}
# include the number of visits to each cell in the map 
ran.tslv <- point.in.poly(ran.loc.sf, r.memory.map.sf) %>% as.data.frame() 
# some of rows will have NA values - need to deal with the missing data later 
ran.tslv
```

# Further data manipulation

```{r}
final.obs.tslv <- obs.tslv %>% mutate(case_ = TRUE) %>% dplyr::select(grid_id, tslv, coords.x1, coords.x2, case_)
colnames(final.obs.tslv) <- c("grid_id","tslv", "x1_", "y1_", "case_")
final.obs.tslv

final.ran.tslv <- ran.tslv %>% mutate(case_ = FALSE) %>% dplyr::select(grid_id, tslv, coords.x1, coords.x2, case_)
colnames(final.ran.tslv) <- c("grid_id","tslv", "x2_", "y2_", "case_")
final.ran.tslv
```


include tslv information to the original data
```{r amt tslv}
# select ssfdat filtered by TRUE and extract the tslv values 
ssfdat.bear.true <- ssfdat.bear %>% filter(case_ == TRUE)
ssfdat.bear.true1 <- ssfdat.bear.true %>% left_join(., final.obs.tslv, by = c("x1_", "y1_", "case_")) 

# same for false  
ssfdat.bear.false <- ssfdat.bear %>% filter(case_ == FALSE)
ssfdat.bear.false1 <- ssfdat.bear.false %>% left_join(., final.ran.tslv, by = c("x2_", "y2_", "case_")) 

# as you can tell, there is NA tslv values in available step lengths - this indicates that they are not generated from the observed locations - so we would like to omit them here as well. 
ssfdat.bear.false1 <- ssfdat.bear.false1 %>% filter(complete.cases(tslv))

# brind all the rows of both used and available locations with tslv information 
ssfdat.bear.final <- rbind(ssfdat.bear.true1, ssfdat.bear.false1) 
ssfdat.bear.final %>% summary()

ssfdat.bear.final 

# save the data 
#write_rds(ssfdat.bear.final, path = here("data", "ssfdat_final_tslv.Rdata"))
```

calculate the time between the last visit to this location and the beginning of our actual trajectory
```{r calculate the actual tslv}
# create a new dataframe 
ssfdat.bear.final1 <- ssfdat.bear.final %>% 
  # create a column that calculates time lag between initial tslv and current tslv so that we set all the points where animals were in within the same grid as 0  
  mutate(tslv1 = abs(lag(tslv) - tslv)) %>%
  # the first row will be NA due to the calculation above - set it as 0 
  mutate(tslv2 = replace_na(tslv1, 0)) %>% 
  # the initial calculation with the lag will also remove the actual tslv for observations that are not within the same grid cells so bring back to the original tslv values for those that were not visited within the same grid 
  mutate(tslv3 = ifelse(tslv2 == 0, tslv2, tslv)) %>%
  # consider every visited locations as 0 as they are considered to be visited previously 
  mutate(tslv4 = ave(tslv3, FUN = function(a) replace(a, duplicated(a), 0))) %>% 
  dplyr::select(-c(tslv, tslv1, tslv2, tslv3))

ssfdat.bear.final1
```


TSLV visualization
[note] the reasonalbe TSLV map should be... 
* high values: occur in the grid cells that are less visited 
* low values: occur in the grid cells that are frequently visited
```{r TSLV visualization}
# overall plot - there is a few steps that has really long TSLV values than the others 
ssfdat.tslv.vis.dat <- ssfdat.bear.final1 %>% filter(step_id_ > 365 & case_ == TRUE) %>% dplyr::select(x1_, y1_, tslv4) %>% 'colnames<-'(c("x","y", "tslv"))

ssfdat.tslv.vis.dat

# visualize the tslv 
tslv.visualization <-  ggplot()+
  geom_sf(data = memory.map.sf, fill = "white")+
  #geom_path(data = ssfdat.tslv.vis.dat, aes(x=x, y=y, col = tslv))+
  geom_point(data = ssfdat.tslv.vis.dat, aes(x=x, y=y, col = tslv), size =1.5)+
  scale_color_viridis(option = "viridis")+
  theme_bw()


tslv.visualization

# save the image 
#ggsave("tslv.plot.png", tslv.visualization, width = 10, height = 5, dpi = 700, bg = NA)
```


## FitSSF
```{r fit ssf}
# only resource predictor 
ssfdat.bear.final1 %>% filter(step_id_ > 365) %>% amt::fit_issf(case_ ~ berries+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()

# TSLV predictor included
ssfdat.bear.final1 %>% filter(step_id_ > 365) %>% amt::fit_issf(case_ ~ berries+ tslv4+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()

# Interaction between TSLV and berries
ssfdat.bear.final1 %>% amt::fit_issf(case_ ~ berries+ tslv4+ tslv4:berries+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()
```

## Footer
```{r footer}
sessionInfo()
```