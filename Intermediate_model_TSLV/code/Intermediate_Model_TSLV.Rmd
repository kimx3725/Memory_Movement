---
title: "1.amt_conv"
author: "Dennis Kim"
date: "2022-10-06"
output: html_document
---

# Objective 

To explore the structure of the bear data set. To do this, I will: 

1. Generate used and available locations of the bear through amt framework. 
2. Extract habitat covariate from habitat layer. 
3. Create a sf polygon per each step length representing a buffer 
4. Calculate the points that fall within each buffer and count the number of locations that revisited 
5. Similar to Uli's paper, the locations that are visited to each buffer will count as 0, otherwise +1 
6. Include TSLV values per each observations throughtout the time and save them in the column of the data 
7. Fit SSF model with a TSLV predictor 

## Document Preamble 
```{r preamble, include = FALSE}
# load libraries
library(knitr)
library(dplyr)
library(readr)
library(data.table)
library(DT)
library(here)
library(stringr)
library(tidyr)
library(purrr)
library(amt)
library(ggplot2)
library(raster)
library(sf)
library(recurse)
library(scales)
library(sp)
library(geosphere)
library(generics)
library(sfheaders)
library(lubridate)
library(pastecs)
library(stats)
options(width = 150)

# set knitr options 
opts_chunk$set(fig.width = 6, fig.height = 5, comment = NA)
```

## Tracking data 

Read in the gps data 
```{r read gps data}
# Location data of the bear 
bear <- read.csv(here::here("data", "GF1143_raw.csv"))

# change the time format of the data 
bear$datetime <- as.POSIXct(bear$datetime, format =  "%Y-%m-%d %H:%M")

# summary of the data
summary(bear)
```

Plot the data 
```{r bear location vis}
ggplot(bear, aes(x = x, y = y))+ 
  geom_point()
```

## Prepare environmental data 

Add environmental covariate (berry)
```{r habitat layer}
# call the berries layer
berry <- raster(here("data/berries/berries.tif"))

# plot the layer
plot(berry)

# crs of the layer 
crs(berry)
```


## amt conversion 

Add a track class to the data and summarize the data 
```{r amt conversion}
# make tracks 
trk.bear <- amt::make_track(bear, .x=x, .y=y, .t=datetime, crs=CRS("+init=epsg:26908"))

summary(trk.bear)
```

Summarize the sampling rates of the bear
```{r sampling rates}
# 4 hour sampling seems reasonable - no need to resample - since it is already resampled 
summarize_sampling_rate(trk.bear) 
```

change the track point to step 
1. Resample track and filter bursts 
2. Convert track to steps 
3. Create random steps 
4. Extract covariate values 
```{r retrk bear}
# follow the above approach 
ssfdat.bear <- 
  trk.bear %>% track_resample(rate = hours(4), tolerance = minutes(30)) %>% 
  steps_by_burst() %>% 
  random_steps(n_control = 1) %>% 
  extract_covariates(berry) %>% 
  filter(!is.na(ta_))

# summary of the ssf data
summary(ssfdat.bear)
```

Check the reasonable buffer distance for each step length - I will pick 500m as a buffer distance from the step lengths 
```{r sl distribution}
ssfdat.bear %>% filter(case_ == "TRUE") %>% dplyr::select(sl_) %>% summary()
```

## Create step points

select randomized and used locations of the tracks from the ssfdat.bear
```{r st points}
# select random locations that matched with observed step lengths 
obs <- ssfdat.bear %>% filter(case_ == "TRUE")

ran <- ssfdat.bear %>% filter(case_ == FALSE)
matched.ran <- subset(ran, x1_ %in% obs$x1_)

# select observed locations
obs.loc <- obs %>% dplyr::select(x1_, y1_)
colnames(obs.loc) <- c("x", "y")
obs.loc.sf <- st_as_sf(obs.loc, coords = c("x", "y"), crs = "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs")
obs.loc.sf %>% head()

# select random locations
ran.loc <- matched.ran %>% dplyr::select(x2_, y2_)
colnames(ran.loc) <- c("x", "y")
ran.loc.sf <- st_as_sf(ran.loc, coords = c("x", "y"), crs = "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs")
ran.loc.sf %>% head()
```

## create a buffer grids

create a sf linestring object representing a step length between 2 observed locations within the whole trajectory 
```{r sl creation}
# select observed locations only    
obs.step <- obs %>% dplyr::select(x1_,y1_, x2_, y2_)
colnames(obs.step) <- c("x1", "y1", "x2", "y2")
head(obs.step)

# make a sf linestring representing each step length
## functions for making sf linestrings
make_line <- function(xy2){
    st_linestring(matrix(xy2, nrow=2, byrow=TRUE))
}

make_lines <- function(df, names=c("x1","y1","x2","y2")){
    m = as.matrix(df[,names])
    lines = apply(m, 1, make_line, simplify=FALSE)
    st_sfc(lines)
}

sf_pts_to_lines <- function(df, names=c("x1","y1","x2","y2")){
    geom = make_lines(df, names)
    df = st_sf(df, geometry=geom)
    df
}

# make linestrings (step length) geometry
sl_df <- sf_pts_to_lines(obs.step) %>% dplyr::select(geometry)

# set the crs 
st_crs(sl_df) <- "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs"

head(sl_df)

# plot the SL geometry
plot(sl_df)
```

calculate the buffer area with the 500m distance from each focal step length 
```{r sl buffer}
# create 500 m buffer zone of each step length
sl.buffer = st_buffer(sl_df, 500)

# plot the sl buffer 
plot(sl.buffer)
```


## Time Since Last Vitist (TSLV)

Follow Uli's approach: Their definition of TSLV is short and sweet (see equation 4 in that paper) - basically, it's 0 if the point in question is within some distance Î´ (this value could be similar to the value you used for your buffer) of the previous point, and otherwise it's (previous TSLV + 1). So they define it iteratively, starting at the first point and iteratively updating TSLV with each time step.

### Observed locations with updated TSLV

Observed points within the step length buffers
```{r obs: yes within or no}
# check if it is working properly by plotting the first sl buffer with points
#plot(sl.buffer$geometry[1]) # select the buffer of the first step length
#plot(obs.loc.sf$geometry, add = TRUE) # put all the locations to see if some of them are within the location

# identify if any points are within each step length bufferzone 
obs.within.buffer <- st_contains(sl.buffer, obs.loc.sf)
# convert to df 
obs.within.buffer <- obs.within.buffer %>% as.data.frame()
# change the colnames - the inital df will have 2 columns called row.id and col.id - this represnts row.id as buffer id and col.id as pt id that is counted within the buffer 
colnames(obs.within.buffer) <- c("grid.id", "observation.id")
# check the data
head(obs.within.buffer)
```

```{r obs: inital prep}
# set the time index data 
## index
index.data <- data.frame(1:534)
colnames(index.data) <- "observation.id"

# create a list to store data frame
## total observation list 
obs.grid.list <- list()

# for loop for calculating the tslv 
for (i in 1:534) {
  # group by grid id and filter information of observation visit per unique grid 
  obs.grid.list[[i]] <- obs.within.buffer %>% group_by(grid.id) %>% filter(grid.id == i)
  # ungroup each list 
  obs.grid.list[[i]] <- obs.grid.list[[i]] %>% ungroup(grid.id)
  # create a tslv, set the areas observation used as 0  
  obs.grid.list[[i]] <- obs.grid.list[[i]] %>% mutate(tslv = 0)
  # add the time index information (534 time step) to the data so that we could capture the tslv between observed locations
  obs.grid.list[[i]] <- index.data %>% left_join(obs.grid.list[[i]], by = "observation.id")
  # fill out the grid id 
  obs.grid.list[[i]] <- obs.grid.list[[i]] %>% mutate(grid.id = i)
  
  # update the tslv values 
  obs.grid.list[[i]] <- obs.grid.list[[i]] %>% 
  # create a indicator column where all the traveling time steps considered as 1 first 
  mutate(tslv1 = replace_na(tslv, 1)) %>% 
  # group by visited observations 
  mutate(grp = cumsum(tslv1 == 0)) %>%
  group_by(grp) %>% 
  # +1 to tslv as the animals traveling outside the visited location and reset as 0 when they visit the next location and restart counting the tslv  
  mutate(tslv2 = ifelse(tslv1 == 1, lag(cumsum(tslv1 == 1))+1, 0)) %>% 
  # replace the first step the animal is away from the visited location as 1 since it was converted back to NA due to the prior condition codes  
  mutate(tslv3 = replace_na(tslv2, 1)) %>% 
  # ungroup by grp
  ungroup(grp) %>% 
  # only select the final output of calculated tslv 
  dplyr::select(c(grid.id, observation.id, tslv3)) 

  # rename the column for further analysis 
  colnames(obs.grid.list[[i]]) <- c("grid.id", "observation.id", "TSLV")
}
```

Take a look at some dataframe per grid to check if the tslv is updated right
```{r obs: tslv inspection}
# first grid 
obs.grid.list[[1]]

# last grid
obs.grid.list[[534]]
```

Select the last row of each dataframe that captures the tslv values for further analysis 
```{r obs: tslv filter}
# select the last row per each dataframe 

# create a true list for tslv 
tslv.list = list()

for (i in 1:534) {
tslv.list[[i]] <- obs.grid.list[[i]] %>% tail(., n = 1)  
}
```


Now we will bind the list of dataframes representing each observation throughout the time to one dataframe.
```{r obs: last bit clearning}
# history of tslv per grid
obs.point.tslv <- rbindlist(obs.grid.list, fill = TRUE)

# save the data 
#write_rds(obs.point.tslv, path = here("data", "obs.point.tslv.Rdata"))

# actual tslv data we will use for further analysis 
obs.tslv <- rbindlist(tslv.list, fill = TRUE) %>% dplyr::select(-observation.id)
obs.tslv %>% summary()

# save the data 
#write_rds(obs.tslv, path = here("data", "obs.tslv.Rdata"))
```

### random locations with updated TSLV

[Do the exact same framework as above]

Get the information about the random points within each buffer grid
```{r random: yes within or no}
# check if it is working properly by plotting the first sl buffer with points
#plot(sl.buffer$geometry[1]) # select the buffer of the first step length
#plot(ran.loc.sf$geometry, add = TRUE) # put all the locations to see if some of them are within the location

# identify if any points are within each step length bufferzone 
ran.within.buffer <- st_contains(sl.buffer, ran.loc.sf)
# convert to df 
ran.within.buffer <- ran.within.buffer %>% as.data.frame()
# change the colnames - the inital df will have 2 columns called row.id and col.id - this represnts row.id as buffer id and col.id as pt id that is counted within the buffer 
colnames(ran.within.buffer) <- c("grid.id", "observation.id")
# check the data
head(ran.within.buffer)
```

```{r ran:inital prep}
# we will use the same index data we created for the previous analysis 

# create a list to store data frame
## total random list 
ran.grid.list <- list()

# for loop for calculating the tslv 
for (i in 1:534) {
  # group by grid id and filter information of observation visit per unique grid 
  ran.grid.list[[i]] <- ran.within.buffer %>% group_by(grid.id) %>% filter(grid.id == i)
  # ungroup each list 
  ran.grid.list[[i]] <- ran.grid.list[[i]] %>% ungroup(grid.id)
  # create a tslv, set the areas observation used as 0  
  ran.grid.list[[i]] <- ran.grid.list[[i]] %>% mutate(tslv = 0)
  # add the time index information (534 time step) to the data so that we could capture the tslv between observed locations
  ran.grid.list[[i]] <- index.data %>% left_join(ran.grid.list[[i]], by = "observation.id")
  # fill out the grid id 
  ran.grid.list[[i]] <- ran.grid.list[[i]] %>% mutate(grid.id = i)
  
  # update the tslv values 
  ran.grid.list[[i]] <- ran.grid.list[[i]] %>% 
  # create a indicator column where all the traveling time steps considered as 1 first 
  mutate(tslv1 = replace_na(tslv, 1)) %>% 
  # group by visited observations 
  mutate(grp = cumsum(tslv1 == 0)) %>%
  group_by(grp) %>% 
  # +1 to tslv as the animals traveling outside the visited location and reset when they visit the next location and restart counting the tslv  
  mutate(tslv2 = ifelse(tslv1 == 1, lag(cumsum(tslv1 == 1))+1, 0)) %>% 
  # replace the first step the animal is away from the visited location as 1 since it was converted back to NA due to the prior condition codes  
  mutate(tslv3 = replace_na(tslv2, 1)) %>% 
  # ungroup by grp
  ungroup(grp) %>% 
  # only select the final output of calculated tslv 
  dplyr::select(c(grid.id, observation.id, tslv3)) 

  # rename the column for further analysis 
  colnames(ran.grid.list[[i]]) <- c("grid.id", "observation.id", "TSLV")
}
```

Take a look at some dataframe per observation to check if the tslv is updated right
```{r ran:tslv inspection}
# first observation 
ran.grid.list[[1]]

# last observation 
ran.grid.list[[534]]
```

Select the last row of each dataframe that captures the tslv values for further analysis 
```{r ran: tslv filter}
# select the last row per each dataframe 

# create a true list for tslv 
tslv.list1 = list()

for (i in 1:534) {
tslv.list1[[i]] <- ran.grid.list[[i]] %>% tail(., n = 1)  
}
```

Now we will bind the list of dataframes representing each observation throughout the time to one dataframe.
```{r ran: last bit clearning}
# whole dataframe 
ran.point.tslv <- rbindlist(ran.grid.list, fill = TRUE)

# save the data 
#write_rds(ran.point.tslv, path = here("data", "ran.point.tslv.Rdata"))

# actual tslv data we will use for further analysis 
ran.tslv <- rbindlist(tslv.list1, fill = TRUE) %>% dplyr::select(-observation.id)
ran.tslv %>% summary()

# save the data 
#write_rds(ran.tslv, path = here("data", "ran.tslv.Rdata"))
```

### Merge the data

Merge the updated tslv information to each observed and random sf point data
```{r merge tslv}
# Observed sf - create an id column for the points 
obs.loc.sf <- obs.loc.sf %>% mutate(grid.id = c(1:534))

# Random sf - Apply same below 
ran.loc.sf <- ran.loc.sf %>% mutate(grid.id = c(1:534))
```

merge the tslv information to the point data 
```{r convert sf to df tslv}
# observe 
obs.df <- left_join(obs.loc.sf, obs.tslv)

ran.df <- left_join(ran.loc.sf, ran.tslv)

# convert geometry back to lat and long
## observed
obs.df1 <- obs.df %>% mutate(x = unlist(map(obs.df$geometry,1)),
                   y = unlist(map(obs.df$geometry,2))) %>% dplyr::select(x, y, grid.id, TSLV) %>% st_drop_geometry()

## random
ran.df1 <- ran.df %>% mutate(x = unlist(map(ran.df$geometry,1)),
                   y = unlist(map(ran.df$geometry,2))) %>% dplyr::select(x, y, grid.id, TSLV) %>% st_drop_geometry() 
```

include tslv information to the original data
```{r amt tslv}
# extract updated tslv values per observed and random locations 
obs.loc.TSLV <- left_join(obs.loc, obs.df1) %>% mutate(case_ = TRUE) %>% dplyr::select(-grid.id)
colnames(obs.loc.TSLV) <- c("x1_", "y1_", "tslv", "case_")
obs.loc.TSLV %>% head()

ran.loc.TSLV <- left_join(ran.loc, ran.df1) %>% mutate(case_ = FALSE) %>% dplyr::select(-grid.id)
colnames(ran.loc.TSLV) <- c("x2_", "y2_", "tslv", "case_")
ran.loc.TSLV %>% head()

# select ssfdat filtered by TRUE and extract the tslv values 
ssfdat.bear.true <- ssfdat.bear %>% filter(case_ == TRUE)
ssfdat.bear.true1 <- ssfdat.bear.true %>% left_join(., obs.loc.TSLV, by = c("x1_", "y1_", "case_")) 
ssfdat.bear.true1 %>% head()

# same for false  
ssfdat.bear.false <- ssfdat.bear %>% filter(case_ == FALSE)
ssfdat.bear.false1 <- ssfdat.bear.false %>% left_join(., ran.loc.TSLV, by = c("x2_", "y2_", "case_")) 
# as you can tell, there is NA tslv values in available step lengths - this indicates that they are not generated from the observed locations - so we would like to omit them here as well. 
ssfdat.bear.false1 <- ssfdat.bear.false1 %>% filter(complete.cases(tslv))
ssfdat.bear.false1 %>% head()

# brind all the rows of both used and available locations with tslv information 
ssfdat.bear.final <- rbind(ssfdat.bear.true1, ssfdat.bear.false1) 
colnames(ssfdat.bear.final)[14] <- "TSLV"
ssfdat.bear.final %>% summary()

# save the data 
#write_rds(ssfdat.bear.final, path = here("data", "ssfdat_final_tslv.Rdata"))
```
## FitSSF
```{r fit ssf}
# only resource predictor 
ssfdat.bear.final %>% slice(101:n()) %>% amt::fit_issf(case_ ~ berries+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()

# TSLV predictor included
ssfdat.bear.final %>% slice(101:n()) %>% amt::fit_issf(case_ ~ berries+ TSLV+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()

# Interaction between TSLV and berries
ssfdat.bear.final %>% slice(101:n()) %>% amt::fit_issf(case_ ~ berries+ TSLV+ TSLV:berries+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()
```

## Footer
```{r footer}
sessionInfo()
```