---
title: "1.amt_conv"
author: "Dennis Kim"
date: "2022-10-06"
output: html_document
---

# Objective 

To explore the structure of the bear data set. To do this, I will: 

1. Generate used and available locations of the bear through amt framework. 
2. Extract habitat covariate from habitat layer. 
3. Create sf polygons that define the buffer of each grid 
4. Calculate the points that fall within each buffer and save it as each raster layer 
5. Calculate the TSLV similar to Uli's approach 
6. Include TSLV values per each location and save them in the column of the data 
7. Fit SSF model with a TSLV predictor 

## Document Preamble 
```{r preamble, include = FALSE}
# load libraries
library(knitr)
library(dplyr)
library(readr)
library(data.table)
library(DT)
library(here)
library(stringr)
library(tidyr)
library(purrr)
library(amt)
library(ggplot2)
library(ggnewscale)
library(raster)
library(sf)
library(recurse)
library(scales)
library(sp)
library(geosphere)
library(generics)
library(sfheaders)
library(lubridate)
library(pastecs)
library(stats)
library(mapview)
library(tmap)
library(spatialEco)
library(paletteer)
library(wesanderson)
library(doBy)
library(stars)
library(viridis)
library(survival)
options(width = 150)

# set knitr options 
opts_chunk$set(fig.width = 6, fig.height = 5, comment = NA)

# set seed 
set.seed(5000)
```

# Data preparation

## Prepare Tracking data 

Read in the gps data 
```{r read gps data}
# Location data of the bear 
bear <- read.csv(here::here("data", "GF1143_raw.csv"))

# change the time format of the data 
bear$datetime <- as.POSIXct(bear$datetime, format =  "%Y-%m-%d %H:%M")

# summary of the data
summary(bear)
```

Plot the data 
```{r bear location vis}
ggplot(bear, aes(x = x, y = y))+ 
  geom_point()
```

## Prepare environmental data 

Add environmental covariate (berry)
```{r habitat layer}
# call the berries layer
berry <- raster(here("data/berries/berries.tif"))

# plot the layer
plot(berry)

# crs of the layer 
crs(berry)
```


# AMT conversion with habitat predictor 

## amt conversion 

Add a track class to the data and summarize the data 
```{r amt conversion}
# make tracks 
trk.bear <- amt::make_track(bear, .x=x, .y=y, .t=datetime, crs=CRS("+init=epsg:26908"))

summary(trk.bear)
```

Summarize the sampling rates of the bear
```{r sampling rates}
# 4 hour sampling seems reasonable - no need to resample - since it is already resampled 
summarize_sampling_rate(trk.bear) 
```

change the track point to step 
1. Resample track and filter bursts 
2. Convert track to steps 
3. Create random steps (5 random steps)
4. Extract covariate values 
```{r retrk bear}
# follow the above approach 
ssfdat.bear <- 
  trk.bear %>% track_resample(rate = hours(4), tolerance = minutes(30)) %>% 
  steps_by_burst() %>% 
  random_steps(n_control = 10) %>% 
  extract_covariates(berry) %>% 
  filter(!is.na(ta_))

# summary of the ssf data
summary(ssfdat.bear)
```

Check the reasonable buffer distance for each step length - you can adjust this based on the summary of your step lengths 
```{r sl distribution}
ssfdat.bear %>% filter(case_ == "TRUE") %>% dplyr::select(sl_) %>% summary()
```

# Spatial temporal cognitive map

select randomized and used locations of the tracks from the ssfdat.bear for making a map
```{r st points}
# select random locations that matched with observed step lengths 
obs <- ssfdat.bear %>% filter(case_ == TRUE) # filter the used locations only 
ran <- ssfdat.bear %>% filter(case_ == FALSE) # filter the random locations only 

# select observed locations
obs.loc <- obs %>% dplyr::select(x1_, y1_) # select the coordinates 
colnames(obs.loc) <- c("x", "y") # change the coordinates names 
obs.loc.sf <- st_as_sf(obs.loc, coords = c("x", "y"), crs = "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs") # convert the format to sf object 
obs.loc %>% head() # check the head of the converted sf data 

## mapview
#mapview(obs.loc.sf, cex = 3, alpha = 0.5, popup = NULL)

# select random locations (apply the same approaches as above)
ran.loc <- ran %>% dplyr::select(x2_, y2_)
colnames(ran.loc) <- c("x", "y")
ran.loc.sf <- st_as_sf(ran.loc, coords = c("x", "y"), crs = "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs")
ran.loc %>% head()

## mapview
#mapview(ran.loc.sf, cex = 3, alpha = 0.5, popup = NULL)
```

we will first create a grid which the extent equals to the bounding box of the selected points
```{r memory map}
# create an entire locations as sf including random and observed 
all.loc <- rbind(obs.loc, ran.loc) # rbind the observed and random locations together 
all.loc.sf <- st_as_sf(all.loc, coords = c("x", "y"), crs = "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs") # convert to the sf object 

# create 2000m x 2000m grid cell in the map 
memory.map = st_make_grid(all.loc.sf, c(2000, 2000), what = "polygons", square = TRUE)
memory.map # check the grid map 

# convert the map to sf object
memory.map.sf = st_sf(memory.map)

# plot the map
memory.map.sf %>% plot()
memory.map.sf
```

## Time Since Last Vitist (TSLV)

Follow Uli's approach: Their definition of TSLV is short and sweet (see equation 4 in that paper) - basically, it's 0 if the point in question is within some distance Î´ (this value could be similar to the value you used for your buffer) of the previous point, and otherwise it's (previous TSLV + 1). So they define it iteratively, starting at the first point and iteratively updating TSLV with each time step.


General approaches: 
1. create a spatial temporal map with the number of cells (for our cases, we use the 2000m x 2000m buffer).
2. set the burn-in period (365 days - a year) - t index would correlate with the number of observation id 
3. calculate the tslv based on the year observations - at the end of the calculation, all the NAs would replace by 354 
4. continue the same approaches 
5. merge the tslv values to the observed locations 

### Observed Locations 

The entire time periods 
```{r entire}
# create all observed pts in list 
all.obs.list <- list() # save each visited layer 
all.obs.ras.list <- list() # save each visited raster layer

# for the entire 
for(i in 1:nrow(obs.loc.sf)){
# calculate the animal's visitation to a each grid cell (1 indicates animal visited that particular grid, otherwise 0)  
all.obs.list[[i]] <- memory.map.sf %>% mutate(visit = lengths(st_intersects(memory.map.sf, obs.loc.sf[i,1])))

# convert to raster
all.obs.ras.list[[i]] <- all.obs.list[[i]] %>% raster(ncol= 26, nrow = 29)

# insert the visited value per each raster map
values(all.obs.ras.list[[i]]) <- all.obs.list[[i]]$visit
}

# check 
all.obs.ras.list[[1]] %>% plot()
```

### calculate the time since last visit

Write function to calculate run length (v.idx) to specified value (y). If the specified run value (y) is the first value it returns a 0 and if it is missing then a NA is returned.
```{r tslv}
# tslv function
## x: the animal's run value 
## y: target run value 
## dir: direction - LR (left to right) & RL (right to left)

time.since.last.visit <- function(x, y=1, dir=c("LR", "RL")) {
    if(dir[1] == "RL") x <- rev(x)
    # compute the lengths and values of runs in a vector -- or the reverse operation
      x.idx <- rle(x)$values 
      v.idx <- rle(x)$lengths 
    # if the x is equal to y (1) visited   
    if(x[1] == y) {
      # then equal to 0
      v <- 0
    } else {
      # calculate the time since the last visit
      v <- v.idx[which(x.idx == y)-1][1]
    }   
  return( v )
}

## stack all the raster layers: each layer will have a value of one observation at time t 
allr = raster::brick(all.obs.ras.list)
## calculate tslv 
(all.tslv <- calc(allr, fun=time.since.last.visit))

## plot the burn-in phase tslv values 
all.tslv %>% plot()

#Now, apply it to a raster stack example
obs.memory.map.sf <- memory.map.sf %>% mutate(tslv = values(all.tslv)) 

# only 135 individuals that have tslv values 
obs.memory.map.sf %>% data.frame() %>% filter(!is.na(tslv))
```

Now we will have tslv based on how many datapoints the animal has been since the grid cell was visited.
```{r obs: count grid}
# count number of points in each grid
obs.memory.map.sf$visit = lengths(st_intersects(obs.memory.map.sf, obs.loc.sf))
obs.memory.map.sf$grid_id <- 1:nrow(obs.memory.map.sf)
# you can clear see that there are some missing values althought animals definitely have visited the locations - need to deal with the missing locations 

obs.memory.map.sf %>% as.data.frame() 
#obs.memory.map.sf %>% as.data.frame() %>% mutate(tslv1 = ifelse(is.na(tslv), 365, tslv))
```

Plot the cognitiv msp over the entire burn in time periods (dark color indicates more tslv values)
```{r, obs:grid map}
tmap_mode("view")

all_map_obs = tm_shape(obs.memory.map.sf) +
  tm_fill(
    col = "tslv",
    palette = "Reds",
    style = "cont",
    title = "Time since last visit",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.5,
    popup.vars = c(
      "Time Since last visit: " = "tslv"
    ),
    popup.format = list(
      tslv = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

all_map_obs
```

convert geometry back to lat and long
```{r obs:geom to latlong}
# include the number of visits to each cell in the map 
obs.tslv <- point.in.poly(obs.loc.sf, obs.memory.map.sf) %>% as.data.frame() %>% 'colnames<-'(c("pt.ids", "tslv", "visit", "grid_id", "x", "y"))
obs.tslv

# include time of the locations
obs.t <- obs %>% dplyr::select(x1_, y1_, t1_) %>% 'colnames<-'(c("x","y", "t"))
obs.t

# merge the time to the tslv data
obs.tslv.tot <- left_join(obs.tslv, obs.t)
obs.tslv.tot
```

## Random Locations 

*[Do the exact same framework as above]*
```{r entire}
# create all observed pts in list 
ran.obs.list <- list() # save each visited layer 
ran.obs.ras.list <- list() # save each visited raster layer

# for the entire  
for(i in 1:nrow(ran.loc.sf)){
# calculate the animal's visitation to a each grid cell (1 indicates animal visited that particular grid, otherwise 0)  
ran.obs.list[[i]] <- memory.map.sf %>% mutate(visit = lengths(st_intersects(memory.map.sf, ran.loc.sf[i,1])))

# convert to raster
ran.obs.ras.list[[i]] <- ran.obs.list[[i]] %>% raster(ncol= 26, nrow = 29)

# insert the visited value per each raster map
values(ran.obs.ras.list[[i]]) <- ran.obs.list[[i]]$visit
}

ran.obs.ras.list[[5]] %>% plot()
```

### calculate the time since last visit

Write function to calculate run length to specified value. If the specified run value (y) is the first value it returns a 0 and if it is missing then a NA is returned.
```{r tslv}
## stack ran the raster layers: each layer will have a value of one observation at time t 
ranr = raster::brick(ran.obs.ras.list)
## calculate tslv (apply the same function)
(ran.tslv <- calc(ranr, fun=time.since.last.visit))

## plot the burn-in phase tslv values 
ran.tslv %>% plot()

#Now, apply it to a raster stack example
r.memory.map.sf <- memory.map.sf %>% mutate(tslv = values(ran.tslv)) 

# only 135 individuals that have tslv values 
r.memory.map.sf %>% data.frame() %>% filter(!is.na(tslv))
```

```{r ran: count grid}
# count number of points in each grid
r.memory.map.sf$visit = lengths(st_intersects(r.memory.map.sf, ran.loc.sf))
r.memory.map.sf$grid_id <- 1:nrow(r.memory.map.sf)
# you can clear see that there are some missing values althought animals definitely have visited the locations - need to deal with the missing locations 

memory.map.sf %>% as.data.frame() %>% summary
#memory.map.sf %>% as.data.frame() %>% mutate(tslv1 = ifelse(is.na(tslv), 365, tslv))
```

Plot the cognitiv msp over the entire burn in time periods (dark color indicates more tslv values)
```{r, obs:grid map}
tmap_mode("view")

r_map_obs = tm_shape(r.memory.map.sf) +
  tm_fill(
    col = "tslv",
    palette = "Reds",
    style = "cont",
    title = "Time since last visit",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.5,
    popup.vars = c(
      "Time Since last visit: " = "tslv"
    ),
    popup.format = list(
      tslv = list(format = "f", digits = 0)
    )
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

r_map_obs
```

convert geometry back to lat and long
```{r obs:geom to latlong}
# include the number of visits to each cell in the map 
ran.tslv <- point.in.poly(ran.loc.sf, r.memory.map.sf) %>% as.data.frame() %>% 'colnames<-'(c("pt.ids", "tslv", "visit", "grid_id", "x", "y"))
# some of rows will have NA values - need to deal with the missing data later 
ran.tslv

# include time of the locations
ran.t <- ran %>% dplyr::select(x2_, y2_, t2_) %>% 'colnames<-'(c("x","y", "t"))
ran.t

# merge the time to the tslv data
ran.tslv.tot <- left_join(ran.tslv, ran.t)
ran.tslv.tot
```

# Further data manipulation

```{r final data merge}
final.obs.tslv <- obs.tslv.tot %>% mutate(case_ = TRUE) %>% dplyr::select(grid_id, tslv, x, y, t, case_)
colnames(final.obs.tslv) <- c("grid_id","tslv", "x1_", "y1_", "t1_" ,"case_")
final.obs.tslv

final.ran.tslv <- ran.tslv.tot %>% mutate(case_ = FALSE) %>% dplyr::select(grid_id, tslv, x, y, t, case_)
colnames(final.ran.tslv) <- c("grid_id","tslv", "x2_", "y2_", "t2_", "case_")
final.ran.tslv
```

include tslv information to the original data
```{r amt tslv}
# select ssfdat filtered by TRUE and extract the tslv values 
ssfdat.bear.true <- ssfdat.bear %>% filter(case_ == TRUE)
ssfdat.bear.true1 <- ssfdat.bear.true %>% left_join(., final.obs.tslv, by = c("x1_", "y1_", "t1_","case_")) 

# same for false  
ssfdat.bear.false <- ssfdat.bear %>% filter(case_ == FALSE)
ssfdat.bear.false1 <- ssfdat.bear.false %>% left_join(., final.ran.tslv, by = c("x2_", "y2_", "t2_", "case_")) 

# brind all the rows of both used and available locations with tslv information 
ssfdat.bear.final <- rbind(ssfdat.bear.true1, ssfdat.bear.false1) 
ssfdat.bear.final %>% summary()

ssfdat.bear.final 
```

calculate the time between the last visit to this location and the beginning of our actual trajectory [First observation points only]
```{r calculate the actual tslv on observed locations}
# select the data
bear.tslv <- ssfdat.bear.final %>% dplyr::select(x1_, y1_, t1_, x2_, y2_, t2_, case_, step_id_,grid_id, tslv)
# sort by step id 
bear.tslv <- bear.tslv[order(bear.tslv$step_id_),]
# check the data 
bear.tslv

# current data format is step wise - we convert it to the longer format to represent points instead of step 
## observed pts
bear.obs.pts <- bear.tslv %>% filter(case_ == TRUE) %>% dplyr::select(x1_, y1_, t1_, case_, step_id_, grid_id, tslv) %>% 'colnames<-'(c("x","y", "t", "case", "step_id", "grid_id", "tslv"))

# calculate the time since last visit - NA for the grid that the animal has never visited it before
setDT(bear.obs.pts)[, tslv := c(NA, diff(t)), by = grid_id]

bear.obs.pts

## random pts 
bear.ran.pts <- bear.tslv %>% filter(case_ == FALSE) %>% dplyr::select(x2_, y2_, t2_, case_, step_id_, grid_id, tslv) %>% 'colnames<-'(c("x","y", "t", "case", "step_id", "grid_id", "tslv"))

bear.ran.pts$tslv <- NA

bear.ran.pts

### calculate the tslv for random points (only based on the used points)

## rbind the data 
bear.pts.tslv <- rbind(bear.obs.pts, bear.ran.pts)
bear.pts.tslv <- bear.pts.tslv[order(bear.pts.tslv$step_id),] # sort by step id 
colnames(bear.pts.tslv)[7] <- "obs.tslv"

bear.pts.tslv
```

Calculate the TSLV values for random points based on the observed points 
```{r calculate the tslv for the random points}
# copy the current data frame 
bear.pts.tslv1 <- bear.pts.tslv
bear.pts.tslv1

# create a random location revisitation only based on the observed locations
bear.pts.tslv1 <- setDT(bear.pts.tslv1)[, ran.loc.tslv.id := ifelse(case != lag(case), diff(t), 0), by = grid_id]
bear.pts.tslv1

# only filter the non-missing indicator values and calculate the tslv of the random locations based on the observed locations and convert it to unit hours
bear.pts.tslv1 <- bear.pts.tslv1 %>% filter(!is.na(ran.loc.tslv.id)) %>% mutate(result = t - lag(t)) %>% mutate(result = hour(seconds_to_period(result))) 

# For the only random points, replace the 0 tslv values with the first observation per step_id 
bear.pts.tslv1 <- bear.pts.tslv1 %>% filter(case == FALSE) %>% group_by(step_id, grid_id) %>% mutate(result = ifelse(grid_id == first(grid_id), across(result, first), NA)) %>% ungroup %>% unnest()

# replace 0 to NA since it is indicating of the non visit 
bear.pts.tslv1$result <- na_if(bear.pts.tslv1$result, 0)

# check the data
bear.pts.tslv1
```

join the random location tslv to the observed location tslv data 
```{r join ran and obs tslv}
# only select the result column which is the true ran tslv values 
bear.pts.tslv1 <- bear.pts.tslv1 %>% dplyr::select(x, y, t, step_id, grid_id, result)
# change the column names 
colnames(bear.pts.tslv1)[6] <- "ran.tslv"
bear.pts.tslv1

# left join the observed tslv values and random tslv values 
bear.pts.tslv2 <- left_join(bear.pts.tslv, bear.pts.tslv1, by = c("x", "y", "t", "step_id", "grid_id"))
bear.pts.tslv2

# coalesce the observed and random values togehter 
bear.pts.tslv3 <- bear.pts.tslv2 %>% mutate(final.tslv = coalesce(obs.tslv, ran.tslv))
bear.pts.tslv3

# only select the actual final tslv values 
bear.pts.tslv4 <- bear.pts.tslv3 %>% dplyr::select(-c(obs.tslv, ran.tslv))
bear.pts.tslv4 <- bear.pts.tslv4[order(bear.pts.tslv4$step_id),]
bear.pts.tslv4
```

merge back to the original data 
```{r merge back}
# sort by step id 
ssfdat.bear.final <- ssfdat.bear.final[order(ssfdat.bear.final$step_id_),]
# replace the original data tslv value to the actual tslv values
ssfdat.bear.final$tslv <- bear.pts.tslv4$final.tslv 

# slice the data until it reaches to the first observed locations 
#ssfdat.bear.final <- ssfdat.bear.final  %>% slice(which.max(case_ == TRUE) : n())

# check the data 
ssfdat.bear.final %>% dplyr::select(t1_,t2_,step_id_, case_, grid_id, tslv)

# save the trk data with the tslv calculated 
#write_rds(ssfdat.bear.final, path = here("data", "ssfdat_final_tslv.Rdata"))
```

TSLV visualization
[note] the reasonalbe TSLV map should be... 
* high values: occur in the grid cells that are less visited 
* low values: occur in the grid cells that are frequently visited
```{r TSLV visualization}
# overall plot - there is a few steps that has really long TSLV values than the others 
ssfdat.tslv.vis.dat <- bear.pts.tslv4 %>% mutate(year = year(t))  %>% filter(year > "2005" & case == TRUE & !is.na(final.tslv)) %>% dplyr::select(x, y, final.tslv) %>% 'colnames<-'(c("x","y", "tslv"))

ssfdat.tslv.vis.dat

# visualize the tslv 
tslv.visualization <-  
  ggplot()+
  geom_sf(data = memory.map.sf, fill = "white")+
  #geom_path(data = ssfdat.tslv.vis.dat, aes(x=x, y=y, col = tslv))+
  geom_point(data = ssfdat.tslv.vis.dat, aes(x=x, y=y, col = tslv), size =1.5)+
  scale_color_viridis(option = "viridis")+
  #new_scale_color()+
  #geom_point(data = subset(ssfdat.tslv.vis.dat, is.na(tslv)), aes(x=x, y=y, col = "red"))+
  #scale_color_manual(name = NULL, labels = "NA", values = "red")+
  theme_bw()


tslv.visualization

# save the image 
#ggsave("tslv.plot.png", tslv.visualization, width = 12, height = 7, dpi = 700, bg = NA)
```

## FitSSF

```{r fit ssf}
# include the column information year for further filtering 
ssfdat.bear.final <- ssfdat.bear.final %>% mutate(year = year(t1_)) 
ssfdat.bear.final %>% summary()

# filtering the burnin phases and replace NA random points TSLV to current time for the random points subtract the burn-in value: 2005-05-24 00:18:00.00
ssfdat.bear.final1 <- ssfdat.bear.final %>% filter(year != "2005") %>% dplyr::mutate(tslv = ifelse(is.na(tslv), difftime(t2_,"2005-05-24 00:18:00.00", units = "hours"), tslv))
ssfdat.bear.final1 %>% summary()

ssfdat.bear.final1

# only berries predictor 
ssfdat.bear.final1 %>% amt::fit_issf(case_ ~ berries+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()

# only tslv predictor 
ssfdat.bear.final1 %>% amt::fit_clogit(case_ ~ berries+ tslv+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()

# Interaction between TSLV and berries
ssfdat.bear.final1 %>% amt::fit_issf(case_ ~ berries+ tslv*berries+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()
```

save the filtered data
```{r save the filtered data}
ssfdat.bear.final1
write.csv(ssfdat.bear.final1, "ssfdat.bear.final.tslv.csv")
```


## Footer
```{r footer}
sessionInfo()
```