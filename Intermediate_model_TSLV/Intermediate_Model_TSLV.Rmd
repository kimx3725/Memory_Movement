---
title: "1.amt_conv"
author: "Dennis Kim"
date: "2022-10-06"
output: html_document
---

# Objective 

To explore the structure of the bear data set. To do this, I will: 

1. Generate used and available locations of the bear through amt framework. 
2. Extract habitat covariate from habitat layer. 

## Document Preamble 
```{r preamble}
# load libraries
library(knitr)
library(dplyr)
library(readr)
library(data.table)
library(DT)
library(here)
library(stringr)
library(tidyr)
library(purrr)
library(amt)
library(ggplot2)
library(raster)
library(sf)
library(recurse)
library(scales)
library(sp)
library(geosphere)
library(generics)
library(sfheaders)
options(width = 150)

# set knitr options 
opts_chunk$set(fig.width = 6, fig.height = 5, comment = NA)
```

## Tracking data 

Read in the gps data 
```{r read gps data}
# Location data of the bear 
bear <- read.csv(here::here("data", "GF1143_raw.csv"))

# change the time format of the data 
bear$datetime <- as.POSIXct(bear$datetime, format =  "%Y-%m-%d %H:%M")

bear
```

Plot the data 
```{r bear location vis}
ggplot(bear, aes(x = x, y = y))+ 
  geom_point()
```

## Prepare environmental data 

Add environmental covariate (berry)
```{r habitat layer}
# call the berries layer
berry <- raster(here("data/berries/berries.tif"))

# plot the layer
plot(berry)

# crs of the layer 
crs(berry)
```


## amt conversion 

Add a track class to the data and summarize the data 
```{r amt conversion}
# make tracks 
trk.bear <- amt::make_track(bear, .x=x, .y=y, .t=datetime, crs=CRS("+init=epsg:26908"))

trk.bear
```

Summarize the sampling rates of the bear
```{r sampling rates}
# 4 hour sampling seems reasonable - no need to resample - since it is already resampled 
summarize_sampling_rate(trk.bear) 
```

change the track point to step 
1. Resample track and filter bursts 
2. Convert track to steps 
3. Create random steps 
4. Extract covariate values 
```{r retrk bear}
ssfdat.bear <- 
  trk.bear %>% track_resample(rate = hours(4), tolerance = minutes(30)) %>% 
  steps_by_burst() %>% 
  random_steps(n_control = 5) %>% 
  extract_covariates(berry) %>% 
  filter(!is.na(ta_))

summary(ssfdat.bear)
```

Check the distribution of step lenghts to define the buffer (5,500 m) is reasonable 
```{r sl distribution}
ssfdat.bear %>% filter(case_ == "TRUE") %>% ggplot(aes(sl_))+geom_histogram(alpha = 0.4)+scale_x_continuous(breaks = seq(0, 9000, by = 1000))
ssfdat.bear %>% filter(case_ == "TRUE") %>% summary()
```

## Time Since Last Visit 

select randomized and used locations of the tracks
```{r st points}
# select observed locations
obs.loc <- ssfdat.bear %>% filter(case_ == "TRUE") %>% dplyr::select(x1_, y1_)
colnames(obs.loc) <- c("x", "y")

# select random locations
ran.loc <- ssfdat.bear %>% filter(case_ == "FALSE") %>% dplyr::select(x2_, y2_)
colnames(ran.loc) <- c("x", "y")

# combine the locations
all.loc <- rbind(obs.loc, ran.loc)
all.loc

# convert the all location to st points 
all.loc.sf <- st_as_sf(all.loc, coords = c("x", "y"), crs = "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs")
all.loc.sf
```


```{r time since last visit calc}
# select observed locations only    
obs.step <- ssfdat.bear %>% filter(case_ == "TRUE") %>% dplyr::select(x1_,y1_, x2_, y2_)
colnames(obs.step) <- c("x1", "y1", "x2", "y2")
head(obs.step)

# make a sf linestring representing each step length
## functions for make sf linestrings
make_line <- function(xy2){
    st_linestring(matrix(xy2, nrow=2, byrow=TRUE))
}

make_lines <- function(df, names=c("x1","y1","x2","y2")){
    m = as.matrix(df[,names])
    lines = apply(m, 1, make_line, simplify=FALSE)
    st_sfc(lines)
}

sf_pts_to_lines <- function(df, names=c("x1","y1","x2","y2")){
    geom = make_lines(df, names)
    df = st_sf(df, geometry=geom)
    df
}

# make linestrings (step length) geometry
sl_df <- sf_pts_to_lines(obs.step) %>% dplyr::select(geometry)

# set the crs 
st_crs(sl_df) <- "+proj=utm +zone=8 +datum=NAD83 +units=m +no_defs"

sl_df

# plot the SL geometry
plot(sl_df)
```

calculate the intersection area between two points of each step length
```{r sl intersection}
# create 500 m buffer zone of each step length
sl.buffer = st_buffer(sl_df, 500)

plot(sl.buffer)
```

Follow Uli's approach: Their definition of TSLV is short and sweet (see equation 4 in that paper) - basically, it's 0 if the point in question is within some distance Î´ (this value could be similar to the value you used for your buffer) of the previous point, and otherwise it's (previous TSLV + 1). So they define it iteratively, starting at the first point and iteratively updating TSLV with each time step.
```{r yes within or no}
# check if it is working properly by plotting the first sl buffer with points
plot(sl.buffer$geometry[1])
plot(all.loc.sf$geometry, add = TRUE)

# identify if any points are within each step length bufferzone 
within.buffer <- st_contains(sl.buffer, all.loc.sf)
# convert to df 
within.buffer <- within.buffer %>% as.data.frame()
# change the colnames
colnames(within.buffer) <- c("buffer.id", "pt.id")
within.buffer

# calculate the tslv of each point based every step buffer
tslv.id <- within.buffer %>% nest_by(pt.id) %>% mutate(tslv = map(data, length)) %>% unnest(tslv) %>% dplyr::select(pt.id, tslv)
tslv.id
```

merge the tslv information to the point data 
```{r merge tslv}
# create an id column for the points 
all.loc.sf <- all.loc.sf %>% mutate(pt.id = c(1:3814))
all.loc.sf

tslv.id

# left merge the data
tslv.df <- left_join(all.loc.sf, tslv.id)

# convert geometry back to lat and long
tslv.df1 <- tslv.df %>% mutate(x = unlist(map(tslv.df$geometry,1)),
                   y = unlist(map(tslv.df$geometry,2))) %>% dplyr::select(x, y, tslv) %>% st_drop_geometry()

tslv.df1
```

include tslv information to the original data
```{r amt tslv}
# extract tslv values per observed and random locations 
obs.loc.tslv <- left_join(obs.loc, tslv.df1) %>% mutate(case_ = TRUE)
colnames(obs.loc.tslv) <- c("x1_", "y1_", "tslv", "case_")
obs.loc.tslv

ran.loc.tslv <- left_join(ran.loc, tslv.df1) %>% mutate(case_ = FALSE)
colnames(ran.loc.tslv) <- c("x2_", "y2_", "tslv", "case_")
ran.loc.tslv

# merge the tslv values per observed and random locations in ssf data 
## first merge the observed locations tslv
ssfdat.bear1 <- left_join(ssfdat.bear, obs.loc.tslv)
ssfdat.bear1

## second merge with the random locations tslv
ssfdat.bear2 <- left_join(ssfdat.bear1, ran.loc.tslv, by = c("x2_", "y2_", "case_"))
ssfdat.bear2

# unite the tslv columns 
ssfdat.bear.final <- ssfdat.bear2 %>% mutate(TSLV = coalesce(tslv.x, tslv.y)) %>% replace_na(list(TSLV = 0)) %>% dplyr::select(-c(tslv.x, tslv.y))
ssfdat.bear.final

# save the data 
#write_rds(ssfdat.bear.final, path = here("data", "ssf_dat.Rdata"))
```


## FitSSF
```{r fit ssf}
ssfdat.bear.final %>% amt::fit_issf(case_ ~ berries+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()

# TSLV predictor
ssfdat.bear.final %>% amt::fit_issf(case_ ~ berries+ TSLV+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()

# TSLV:berries predictor
ssfdat.bear.final %>% amt::fit_issf(case_ ~ berries+ TSLV+ TSLV:berries+ log(sl_)+ cos(ta_)+ strata(step_id_)) %>% summary()
```
*Interpretation*
- TSLV: the general idea is that animals may avoid recently used areas. This may be for many reasons - e.g., a predatory animal like a wolf will not hunt in the same patch because the prey animals there will get used to the presence of a predator and hide. Or alternatively, a grazing forager may exhaust all the vegetation in a patch and be forced to move elsewhere to eat. In areas where the animal has not been recently, it's more likely that resources will be "refreshed", making them more attractive to visit. And of course it is spatial (or spatio-temporal) memory that is driving the animal's ability to navigate to these locations. All in all, this is quite similar to what you have suggested but I figured it's good to provide biological background for what the hypotheses behind this model are.

- TSLV:berries: animals move more slowly in areas that they haven't visited in a while where the berries are present (negative interaction)

## Footer
```{r footer}
sessionInfo()
```